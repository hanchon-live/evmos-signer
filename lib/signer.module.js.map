{"version":3,"file":"signer.module.js","sources":["../src/signer.ts"],"sourcesContent":["const secp = require('secp256k1-native')\n\nfunction reverse(buf: Buffer) {\n    const tmp = []\n\n    let i\n    for (i = 0; i < Math.ceil(buf.byteLength / 2); i++) {\n        tmp.push(buf[i])\n        buf[i] = buf[buf.length - 1 - i]\n    }\n\n    const offset = i\n    for (; i < buf.byteLength; i++) {\n        buf[i] = tmp[2 * offset - i - 1]\n    }\n\n    return buf\n}\n\nexport function signEthSecp256k1(privKey: Buffer, message: Buffer) {\n    if (privKey.byteLength !== secp.secp256k1_SECKEYBYTES) {\n        return null\n    }\n    const ctx = secp.secp256k1_context_create(secp.secp256k1_context_SIGN)\n    const sig = Buffer.alloc(secp.secp256k1_ecdsa_recoverable_SIGBYTES)\n    secp.secp256k1_ecdsa_sign_recoverable(ctx, sig, message, privKey)\n\n    // Reverse the r and s values\n    const r: Buffer = reverse(sig.slice(0, 32))\n    const s: Buffer = reverse(sig.slice(32, 64))\n\n    // const v: Number = sig.readUInt8(64) + 27\n    return sig\n}\n"],"names":["secp","require","reverse","buf","tmp","i","Math","ceil","byteLength","push","length","offset","signEthSecp256k1","privKey","message","secp256k1_SECKEYBYTES","ctx","secp256k1_context_create","secp256k1_context_SIGN","sig","Buffer","alloc","secp256k1_ecdsa_recoverable_SIGBYTES","secp256k1_ecdsa_sign_recoverable","slice"],"mappings":"AAAA,MAAMA,EAAOC,QAAQ,oBAErB,SAASC,EAAQC,GACb,MAAMC,EAAM,GAEZ,IAAIC,EACJ,IAAKA,EAAI,EAAGA,EAAIC,KAAKC,KAAKJ,EAAIK,WAAa,GAAIH,IAC3CD,EAAIK,KAAKN,EAAIE,IACbF,EAAIE,GAAKF,EAAIA,EAAIO,OAAS,EAAIL,GAGlC,MAAMM,EAASN,EACf,KAAOA,EAAIF,EAAIK,WAAYH,IACvBF,EAAIE,GAAKD,EAAI,EAAIO,EAASN,EAAI,GAGlC,OAAOF,WAGKS,EAAiBC,EAAiBC,GAC9C,GAAID,EAAQL,aAAeR,EAAKe,sBAC5B,YAEJ,MAAMC,EAAMhB,EAAKiB,yBAAyBjB,EAAKkB,wBACzCC,EAAMC,OAAOC,MAAMrB,EAAKsB,sCAQ9B,OAPAtB,EAAKuB,iCAAiCP,EAAKG,EAAKL,EAASD,GAGvCX,EAAQiB,EAAIK,MAAM,EAAG,KACrBtB,EAAQiB,EAAIK,MAAM,GAAI,KAGjCL"}